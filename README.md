# x86 汇编语言 - 从实模式到保护模式

> 第1部分：预备知识

---

## 第1章 十六进制计数法

* 进制转换

## 第2章 处理器、内存和指令

* 处理器
  * 寄存器：双向器件，可以在一端接受输入并加以锁存，同时，它也会在另一端产生一模一样的输出
  * 算术逻辑单元/算术逻辑部件(Arithmetic Logic Unit, ALU)：专门负责运算的电路，可以计算加法、减法或者乘法，也可以做逻辑运算
  * 控制器
  * 处理器内部总线
* 字节byte、字word、双字double word
* 尽管内存的最小组成单位是字节，但是，经过精心的设计和安排，它能够按字节、字、双字和四字进行访问（单次访问，而非一个个字节访问后的组合）
* 大端序和小端序
  * 常Little Endian：高字节位于高地址部分
* 指令和指令集
  * 一般来说，指令由操作码和操作数构成，但也有小部分指令仅有操作码，而不含操作数
  * 对于Intel x86处理器来说：指令长度不定，短的1字节，长的可能达到15字节
  * 立即数：操作数直接在指令中给出，不需要再次访问内存
  * 指令和数据要分开存放——代码区和数据区
  * 一个处理器能够识别的指令的集合成为该处理器的**指令集**
* 古老的Intel 8086处理器
  * 是Intel公司第一款16位处理器
  * 处理器内部有8个16位的*通用*（大部分可以根据需要用于多种目的）寄存器：AX、BX、CX、DX、SI、DI、BP、SP
    * 这8个寄存器的前4个又各自可以拆分成两个8位的寄存器来使用：AH、AL...
  * 在指令中使用了绝对内存地址（物理地址），这样的程序是无法定位的。要使用相对地址或逻辑地址，而不能使用真实的物理地址。当程序加载时，这些相对地址还要根据程序实际被加载到的位置重新计算。（重定位）
  * 重定位：任何时候，程序的重定位都是非常棘手的，当然也有好集中解决的办法
    * 8086处理器上，这个问题很好解决，因为处理器访问内存时使用了分段机制
  * 内存分段机制
    * 一个内存单元的地址实际上就可以用“段：偏移”表示，这就是通常所说的**逻辑地址**
    * 为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器CS和数据段寄存器DS
      * 对CS内容的改变将导致处理器从新的代码段开始执行
      * 当处理器访问内存时，它把指令中指定的内存地址看成是段内的**偏移地址**，而不是物理地址。
  * 8086中的内存分段机制
    * 由于8086自身的局限性，它的做法还要复杂一些
    * 8086内部有8个16位通用寄存器，还有4个段寄存器：CS，DS，ES附加段寄存器（可用来指向额外的数据段，默认使用的是DS），SS栈段寄存器
    * IP（Instruction Pointer）是指令指针寄存器，只和CS一起使用（CS指向代码段起始地址，IP指向段内偏移），只有处理器才能改变它的内容。CS：IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令，然后处理器根据当前指令长度改变IP值，使其指向下一指令
    * 段寄存器和IP寄存器都是16位的，按原先方式直接相加只能得到16位的物理地址。但8086却提供了20根地址线（换句话说，它提供的是20位的物理地址）
      * 使用20位地址线是因为16位物理地址只能访问64KB内存，及时那个年代也有点小了。而20位地址线可访问多达1MB的内存
      * 都是16位的寄存器，如何形成20位物理地址？将段寄存器的内容左移4位再和偏移地址相加
    * 最多可以将1MB内存分成65536个段，每个段16字节
      * 8086处理器的逻辑分段，起始地址都是16的倍数，这称为是按照16字节对齐的。
    * 如果不允许段之间重叠，每个段最大长度是64KB，1MB的内存最多可以划分成16个段

## 第3章 汇编语言和汇编软件

## 第4章 虚拟机的安装和使用



> 第2部分：实模式

---

## 第5章 编写主引导扇区代码

## 第6章 相同的功能，不同的代码

* 检测点 6.1

  MOVSB指令每次传送一个**字节**，MOVSW指令每次传送一个**字**。原始数据在段内的偏移地址在寄存器**SI**中，要传送的目标位置的偏移地址在寄存器**DI**中，如果要连续传送多个字或字节，则需要**rep**前缀，在寄存器**CX**中设置传送的次数，并设置传送的方向。其中**cld**指令指示正向传送，**std**指示反向传送。反向传送时，每传送一次，SI和DI的内容将**减小**

* 检测点 6.2

  下面哪些指令是错误的，为什么？

  A. add ax, [bx] 正确

  B. mov ax, [si] 正确

  C. mov ax, [cx] 错误，在8086处理器上，如果要用寄存器来提供偏移地址，只能使用BX、SI、DI、BP

  D. mov dx, [di] 正确

  E. mov dx, [ax] 错误，同C

  F. inc byte [di] 正确

  G. div word [bx] 正确

* 计算机中的负数

  * 如果要扩展有符号数：8位到16位，将其最高位（也就是辨别符号的那一位）扩展到高8位即可
  * 几乎所有的处理器指令既能操作无符号数，又能操作有符号数，有几条除外，如：
    * 除法指令和乘法指令：
      * div工作于无符号数
      * idiv工作于有符号数

* 检测点 6.3

  假如以下声明的是有符号数，那么，其中的负数是：(判断最高位是否为1)

  data0 db **0xf0**, 0x05, 0x66, **0xff**, **0x81**

  data1 dw 0xfff, **0xffff**, 0x8b, **0x8a08**

* 检测点 6.4

  1. 当**ZF=1**时，表明计算结果为0；jz指令的意思是当**ZF=1**，即计算结果为**0**时转移；je指令的意思是当**ZF=1**，即计算结果为**0**时转移；jnz指令的意思是当**ZF=0**，即计算结果不为**0**时转移；jne指令的意思是当**ZF=0**，即计算结果不为**0**时转移。

  2. 写一段小程序，先比较寄存器AX和BX中的数值，然后，当AX的内容大于BX的内容时，转移到标号lbb处执行；等于时，转移到lbz处；AX小于BX时，转移到lbl处：

     ```asm
     cmp BX, AX
     ja lbb
     je lbz
     jb lbl
     ```

* 检测点 6.5

  反汇编命令定位到`jmp near $`，然后在此设置断电，并用"c"连续执行到该断点位置（无限循环），反汇编此语句以及后面的语句，发现Bochs会把后面的一大堆0也反汇编成指令。

* 本章习题

  1. 在某程序中声明和初始化了以下的有符号数。请问，正数和负数各有多少？

     ```assembly
     data1 db 0x05, 0xff, 0x80, 0xf0, 0x97, 0x30
     data2 dw 0x90, 0xfff0, 0xa0, 0x1235, 0x2f, 0xc0, 0xc5bc
     ```

  2. 如果可能的话，尝试编写一个主引导扇区程序来做上面的工作。

     ```assembly
     
     ```

  3. 请问下面的循环将执行多少次：

     ```assembly
     	   mov cx, 0
     delay: loop delay
     times 510-($-$$) db 0
     				 db 0x55 0xaa
     ```

## 第7章 比高斯更快的计算

* 8086处理器的寻址方式
  * 寄存器寻址：最简单的寻址方式，指令执行时，操作的数位于寄存器中，可以从寄存器里取得。
  * 立即寻址：又叫立即数寻址，也就是说，指令的操作数是一个立即数
  * 内存寻址：
    * 直接寻址
    * 基址寻址：在指令的地址部分使用基址寄存器BX或者BP来提供偏移地址
    * 变址寻址：类似基址寻址，唯一不同在于使用的是变址寄存器（或称索引寄存器）SI和DI
    * 基址变址寻址

## 第8章 硬盘和显卡的访问与控制



## 第9章 中断和动态时钟显示



> 第3部分 32位保护模式

---

## 第10章 32位x86处理器编程架构

## 第11章 进入保护模式

## 第12章 存储器的保护

## 第13章 程序的动态加载和执行

## 第14章 任务和特权级保护

## 第15章 任务切换

## 第16章 分页机制和动态页面分配

## 第17章 中断和异常的处理与抢占式多任务

## bochsrc file setup

* basic set up: [me.bxrc](./me.bxrc)
* [The configuration file bochsrc](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html)

